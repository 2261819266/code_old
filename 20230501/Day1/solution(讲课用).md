赛前得分预测 dj>bg>ah>cfk>i>>e

实际得分：d>b>ha>j>c>k>>f>>eig

j.愚者(joker)

真实的签到题。

观察到总共就22张牌，且得分只与最终状态有关，直接状压记录每种状态出现的可能性，对每种可行的状态统计一下概率和即可。

注意结尾的 $0$ 需要特判。

最大复杂度  $O(2^{23})$ ，可以通过。







d.直接了当的题目(direct)

~~题意简述：这题要什么题意简述~~

原本想整个区间dp题，没想到整简单了。

区间dp思路：由短到长枚举区间，对每个区间记录左边的右括号数和右边的左括号数，然后枚举断点，连接两个区间即可。$O(n^3)$

然后我们发现无论断点在哪答案都一致，就不用枚举断点了，$O(n^2)$

所以就可以固定左端点，拉长右端点，直接算就算完了。





g.能力树(game)

讲题人说，要送分，所以就有了这题。

题面比较繁琐，大概是不这样做就没有难度了吧。

简单的题意就是，给一棵树，问如何删去最少的子树使得删后的树中存在一个大小为 $m$ 的子树，对于每个 $m$ 求解。

本题的数据很有梯度。

对于 $35\%$ 的分数暴力枚举删什么边然后跑一遍dfs即可，但是这种题不写正解说不过去吧（

考虑对于已经删了多少条边做树形背包，记 $f_{i,j}$ 表示在以 $i$ 为根的子树中，留有 $j$ 个节点最少需要删去的边数，那么我们考虑每加入一个该点的子树会发生什么。

我们可以将原本算出的这个节点的结果加上新加入的子树的结果，从而更新该节点的结果。但是注意，如果选择完全不加入该子树，则需要删去连向该子树的边。因此我们得到如下转移方程： $f_{u,j} = Min(f_{u,j}+1, f_{u,j - k} + f_{v,k})$ （其中 $v$ 就是新加入的子树的根）。对 $j$ 从大往小更新即可。

最后统计答案的时候， $Max(f_{i,m})$ 就是对应的 $m$ 的答案。







b.兄弟(brother)

记 $f_{i,j}$ 为走到 $i$ 号城市，花费 $j$ 天的概率。

由于小S和小T策略独立，所求答案即为 $\displaystyle \sum_{i=1}^n f_{n,i}^2$

朴素的dp是 $O(n^2)$ 状态，$O(a_i)$ 转移的，无法通过所有数据，需要优化。

我们发现，一个状态其往后的所有转移都在一个区间内，且转移贡献一致，即：贡献为区间加形式。

由此，考虑前缀和优化，我们使用一个辅助数组，运用差分思想，就能 $O(1)$ 转移，复杂度降至 $O(n^2)$ ，可以通过。







f.狒狒食柿(ffxiv)

这是一道有意思的题改编的更有意思的题。

先考虑一个判定性问题：如何确认一个编号 $x$ 能否成为最终编号？

很简单，只要有一个时刻，存在 $k$ 个编号连续的人的编号的第 $\lfloor \frac{k+1}{2} \rfloor$ 小值为该特征值即可。

再给出一个结论：最优策略下， $k$ 只会为 $2$ 或 $3$。

证明：当 $k=2$ 或 $k=3$ 时，只需存在一个不小于 $x$ 的其他特征值即符合条件。

当 $k>3$ 时，根据鸽笼原理，必然存在连续 $3$ 个数，其中有至少 $2$ 个数不小于 $x$，把这个数推至 $x$ 旁即可。

所以设计以下dp：

计 $l[i]$ 为当 $a[1:i]$ 完全一致时，可能出现的最大值；

​    $r[i]$ 为当 $a[i:n]$ 完全一致时，可能出现的最大值。

维护 $l[i],r[i],a[i]$，对于每个 $i$ ，检测 $a[i]$ 是否是一个可行的最终编号。

最后去重输出即可。

复杂度  $O(n)$ 或 $O(n\log n)$

p.s. 这题有另一个做法，时间复杂度相同，需要用到题目的一个性质，有兴趣者可以自行探索。







h.哈希(hash)

算法1：

我会暴力！

对于每组询问，直接 $O(n)$ 枚举计算，期望得分12。

算法2：

我会前缀和优化！

我们记 $T_k= \sum^{k}_{i=1}i \times S(i)$，这样，对于一组 $l,r$，答案为 $T_r-T_{l-1}$。

预处理 $T$，单次询问 $O(1)$，期望得分24。

算法2.5：

我会分块打表！

把 $l,r$ 值域分块，整块打表，散块暴力，期望得分40~44。

算法3：

我会数位DP!

观察到 $S(i)$ 是数位和，容易想到数位DP。

考虑在一个数的最高位前增加一个数，$i \times S(i)$ 的变化量。

设 $i$ 的位数为 $l$，增加的数为 $x$，现在的数字为 $j$，则：

$$j \times S(j)=(x \times 10^l+i)(S(i)+x)=10^l \times x^2+10^l \times S(i) \times x+i \times x+i \times S(i)$$

设 $i_{max}=I$，当 $l,x,I$ 确定时，对 $j \times S(j)$ 求和，有：

$$\sum j \times S(j) =\sum 10^l \times x^2+10^l \times S(i) \times x+i \times x+i \times S(i)$$

$$=10^l \times x^2 \times (I+1)+ 10^l \times x \times \sum^I_{i=0} S(i)+x \times \sum^{I}_{i=0} i+\sum ^{I}_{i=0} i \times S(i)$$

注意到 $\sum^n_{i=1} i,\sum^n_{i=1} S(i)$ 均可以用数位DP思想以 $O(\log n)$ 复杂度完成，因此上式亦可以 $O(\log n)$ 复杂度完成，同时维护即可。

至此，我们解决了 $l=1$ 的询问，期望得分24。

算法4：

结合算法2和算法3，把询问 $ans_{l,r}$ 转换为 $ans_{1,r}-ans_{1,l-1}$;

时间复杂度 $O(t \log n)$，期望得分100。

算法114514：

我会枚举每一位上的数字！

> ​	分类讨论易遗漏，
>
> ​	猝不及防爆long long。
>
> ​	调出正解自得意，
>
> ​	常数优化还不够。

期望得分：0

**本题模数较大，请选手注意及时取模。**





k.绮月之旅(kitsuki)

这是一道因为自己的题被讲题人改编成更有意思的题而恼羞成怒跑出来供题的人送的签到题。

（原先这里应该是一道更毒瘤的题，幸好出题人到了ddl还没解出来，所以换题了）

题意简述就是，给定一个长为 $m$ 的数列 $a_i$ ，求有多少个不同的数列 $b_i$ 使得 $\forall i,a_i \ge b_i$ 且 $b_i \ne b_{i-1}$ 。

注意依题意， $b_0 = n$ ，这里我们判断若 $a_1 = n$ ，则令 $a_1 = n - 1$ 从而规避这个问题。没注意到这一点的同学将喜提 `score--` 。

对于 $20\%$ 的数据，爆搜即可， $O(n^m)$ 。

对于 $40\%$ 的数据，我们dp，在状态中记录上一次的数 $b_i$ ，可以 $O(nm)$ 解决。

之后就是正解了。

我们考虑记 $f_i$ 为考虑到第 $i$ 个数时的方案数，我们希望 $f_i$ 能直接由 $f_{i-1}$ 乘上 $a_i$ 得到。

那有小可爱可能就要问了，不记上一个数是多少的话我们没法剔除当前数和前一个数相同的答案啊。

我们考虑通过其他方式剔除这部分多余的数量，如果当前数填的是 $x$ 且与前一个数相同，那这一类的方案数就是 $f_{i-2}$ ，对于所有可能的 $x$ ，这一部分的总数就是 $f_{i-2}×min\{a_{i-1},a_i\}$ ，我们减去他就行。

那我们又发现，减去的部分减多了，因为可能存在三连数字相同，这一部分包含在了我们目前减去的部分，但是不包含在最初的 $f_{i-1}$ 里。因此我们如法炮制的加上这部分答案 $f_{i-3}×min\{a_{i-2},a_{i-1},a_i\}$ 。然后你意识到又加多了。。。

最终，你得到的式子会长这样：

$f_i=\sum_{j=0}^{i-1}(−1)^{i−j−1} \times f_j \times \min_{k=j+1}^i{a_k}$

于是你手推出了容斥原理

（什么你说你本来就会容斥原理？真巧我也会，但是讲题人不让我直接由容斥得，所以只能这样写了）

于是你得到了 $O(m^2)$ 的做法，可以拿到 $60$ 分。

接下来我们稍微改写一下式子：

$f_i=(-1)^{i-1}\sum_{j=0}^{i-1}(−1)^{j} \times f_j \times \min_{k=j+1}^i{a_k}$

令 $g_i = (-1)^if_j$ 

$f_i=(-1)^{i-1}\sum_{j=0}^{i-1}g_j \times \min_{k=j+1}^i{a_k}$

我们希望能够实时维护这个 $g$ 与最小值的乘积和，从而达到线性的状态转移。

显然随着 $j$ 的增加， $\min_{k=j+1}^i{a_k}$ 只增不减，并形成了很多个相同段。当新出现一个更小的 $a_i$ 时，他会改变右侧的一部分 $\min_{k=j+1}^i{a_k}$ ，而对更左侧无影响。我们用一个栈维护这些值，更新时将栈顶大于 $a_i$ 的元素删除并将 $a_i$ 加入，同时就能方便维护这个乘积和，这种操作叫做单调栈。由于所有点只会入栈出栈各一次，所以总时间复杂度 $O(m)$ 。

于是你 $O(m)$ 实现了这个题





a.攻城(attack)

树形&换根dp

两问其实差不多，第二问略难一些。

首先给出一个最优策略：占领时一定选择能够占领的最大节点占领。

根据题意，占领时是可以走回头路的，所以我们占领了可行最大节点后，原先可占领的节点依旧可以占领，满足题意。

由此形成对1问的一个解：从小到大枚举点，依次把当前点答案贡献到与之相连且大于它的点上，最后对所有点答案取max。

不过这个方法不能很好的扩展到第二问，考虑另一种想法。

我们考虑钦定一个点为根节点，我们从根节点出发，按题意要求占领全树。

在出发点确定的条件下，记  $f_i,g_i$ 分别为第一，第二问的答案，首先给出结论：

$\displaystyle f_i=\sum_{j\in son_i \and j<i}f_j,g_i=\max_{j\in son_i}\{g_j+[j>i]\}$ 

$f_i$ 在上文已充分解释，$g_i$ 的结论可由最优策略推得。

由此，我们可以求出对于一个确定的出发点的答案，换根即可得到每个点为出发点的答案，最后取 $\max / \min$ 即可。

复杂度 $O(n)$











i.浮冰(ice)

~~动态规划的本质是思考~~

算法1:

我会爆搜！

直接搜索记录即可。期望得分20。

算法2:

我会计数！

考虑到 $p_i=0.5$ 时，不动和移动等概率。

通过一些奇妙的方法可能可以拿到者部分分，~~反正我是没想到~~。期望得分30。

算法3：

我会设状态！

本题的难点在于如何建立状态以及由状态求解。

如果直接记 $f_{i,j}$ 为最后一次停留在第 $i$ 块浮冰是第 $j$ 天的概率，转移似乎很难处理。

考虑记 $f_{i,j}$ 为第 $j$ 天在第 $i$ 块浮冰的概率，这是容易求的。

现在考虑最后一次停留在第 $i$ 块浮冰是第 $j$ 天的概率。

我们可以跑一个类似的dp，算出从 $i$ 号浮冰出发，经过 $j$ 天且未再次回到 $i$ 号浮冰的概率。

最后把概率依序相乘即可得到期望。

复杂度 $O(n^2m)$ ，期望得分100。









c.人力公司(company)

~~这题有一个FWT做法，但超纲了，就不讲了（其实是没去想）~~

题意：有 $k$ 个元素和 $n$ 个由这 $k$ 个元素构成的集合 $\{S_n\}$，问由这 $k$ 个元素生成的全部 $2^k-1$ 个非空集合中有多少个 $T$ 集合满足 $\displaystyle T \subseteq \bigcup_{k=1}^i $ ，即最少由 $i$ 个集合能覆盖 $T$ 集合，对于 $i \in [1,k]$ 计算答案。$k \leq 20$，$n \leq 1\times 10^5$ 。

最暴力的做法是 $O(N2^K)$ 

显然一个集合的答案不会小于它的子集，这提示我们可以使用子集DP。

一种可行的思路是：先处理答案为 $1$ 的集合，然后子集dp即可。

但子集DP的时间复杂度是 $O(3^n)$，在 $n=20$ 时无法通过。

考虑优化转移，我们将输入视为二进制，从大到小枚举每个输入的集合，并实时记录最高位，这样就可以只枚举其补集比其小的子集转移，可以通过。

统计答案时，使用高维后缀min维护答案。











e.练习曲(etude)

写在前面：**本题正解具有亿定难度**。

题意简述：你有一个正整数数列，你要把这个数列划分成若干长度不超过 $L$ 的段，使每段权值和最小。一段权值为将最后一位减一后，本段最大值加一。同时，要支持 $q$ 次互不影响的修改。

$v_{l,r}=\max \{\max^{r-1}_{i=l}\{a_i\},a_r\}+1$

对于原问题，显然，我们有一个 $O(nL)$ 的DP。记 $f_i$ 为最后一段结尾为 $i$ 的最小权值和，有

$\displaystyle f_i=\min^{i-1}_{j=i-L} \{ f_j+v_{j,i} \}$

每次修改时重算，时间复杂度为 $O(qnL)$

接下来，存在两个优化。

优化1:

我们发现，如果每次询问都重算一遍全序列，显然是非常劣的。能不能少算一些呢？

我们观察到每次修改都只修改了一位的值，那么，它能影响的段就只有 $L^2$ 个，相对 $nL$ 要优秀不少。我们能否只更新这 $L^2$ 段呢？

答案是可以的。我们发现，在 $x$ 左侧的点，以它为最后一段的结尾的最小权值不受影响，在 $x$ 右侧的点，以它为最前一段的开端的最小权值不受影响(不妨记为 $g_i$ )，那么，我们可以对 $[x,x+L-1]$ 跑一个类似的DP，就解决了。

$f_i$ 与 $g_i$ 可以 $O(nL)$ 预处理，总时间复杂度 $O(nL+qL^2)$

优化2:

我们观察到这个DP状态已经无法优化了，考虑优化转移。

初步观察，我们尝试使用单调队列优化，但是 $f$ 不降，增量不升，没有单调性，无法使用单调队列。

但 $f$ 不降，增量不升是一个很好的性质，尝试使用其他想法。

我们发现，如果 $j$ 与 $j-1$ 都能贡献到 $i$，且 $v_{j,i}=v_{j-1,i}$，那么，用 $j-1$ 贡献一定不劣于用 $j$ 贡献。

进行推广，有：一段能贡献且增量一致的点，我们只需考虑第一个。

那么，我们维护这些点，然后查询其中最小值即可；修改增量时，把最后几段进行合并即可，这可以用**线段树维护双端队列**完成。

复杂度证明：线段树是单次 $O(\log n)$ 的，合并与弹出均为 $O(n)$ 级别，总复杂度为 $O(n \log n)$。

将优化1的询问DP同理优化，时间复杂度 $O(n \log n+qL \log L)$。

std使用了循环队列优化，时间复杂度 $O( (n+qL) \log L)$，可以通过。



